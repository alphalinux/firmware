// $Id: c_csr.mdl,v 1.1.1.1 1998/12/29 21:36:22 paradis Exp $
//
// $Log: c_csr.mdl,v $
// Revision 1.1.1.1  1998/12/29 21:36:22  paradis
// Initial CVS checkin
//
# Revision 1.1  1997/11/12  18:51:39  pbell
# Initial revision
#
// 
///////////////////////////////////////////////////////////////
// Revision 1.56  1997/04/29  15:13:59  razdan
// redefine bc_rd_rd_bubbles(1,0) into bc_rd_rd_bubbles_a and bc_wr_wr_bubbles_a to enable the
// manipulation of commodity bcaches..
//
// Revision 1.55  1997/03/12  22:23:21  jeisenbe
// Added delay flop to write-many chain to match schematics
//
// Revision 1.54  1997/03/03  16:09:40  asher
// Add wires to copy bc_size to raw_bc_size and pad_raw_bc_size.
//
// Revision 1.53  1997/02/25  16:21:54  asher
// Add wire for CX models to make pad_bc_size_a match bc_size_a.
//
// Revision 1.52  1997/02/20  20:40:53  razdan
// name some duplicated signals for chango..
//
// Revision 1.51  1997/02/18  22:11:31  quinn
// changes to support the Tbox adding 16 to it's Cbox data shift count
//
// Revision 1.50  1997/02/14  20:39:10  jeisenbe
// Add CSR chain delay flops to match schematics
//
// Revision 1.49  1997/02/03  15:23:16  quinn
// new Cbox pads
//
// Revision 1.48  1997/01/27  23:44:28  razdan
// add mbox_bc_prb_stall_a csr to fix MBOX probe/bcfill requirement
//
// Revision 1.47  1997/01/13  20:35:15  quinn
// added c_mtv_cfg->write_many_a for regression tests which
// need to init the WRITE_MANY chain before reset
//
// Revision 1.46  1997/01/12  16:03:33  razdan
// reset shifts zero's into write_many chain..
//
// Revision 1.45  1996/12/20  18:18:17  quinn
// disabled CHECKER's during reset
//
// Revision 1.44  1996/12/20  13:55:54  razdan
// match csr chains to schematics
//
// Revision 1.43  1996/12/19  14:55:32  quinn
// qualified inputs from Tbox with t->enable_tbox
//
// Revision 1.42  1996/12/09  20:43:02  razdan
// seperate write_once flop to two latches to allow deposit/force
// add tlaser_io_mode_a to be shiped to MBOX for ldio32 byte
//
// Revision 1.41  1996/11/25  13:49:19  quinn
// more Cbox csr changes
//
// Revision 1.40  1996/11/07  18:49:48  quinn
// allow write_many csr to be re-programmed without getting
// duplicate signal errors
//
// Revision 1.39  1996/11/07  16:49:43  asher
// CXBOX uses real reset now.  Must ifdef out write_once and write_many
// chains driving the iprs so CX models can deposit to the IPRs (from
// command line and Xbox::getInputs.
//
// Revision 1.38  1996/11/06  15:12:17  quinn
// Cbox changes to support Cbox csr changes and new PLL/reset state machine
//
// Revision 1.37  1996/09/23  18:54:08  asher
// Add data_valid_dly, jitter_cmd, bc_wr_rd_bubbles, and bc_cpu_clk_delay
// to the ipr write once chain.
//
// Revision 1.36  1996/09/11  12:21:10  razdan
// CX model updates
//
// Revision 1.35  1996/09/05  12:32:21  razdan
// fixup for new pad model
//
//
// Revision 1.34  1996/08/08  21:55:45  quinn
// simplified the fake srom
//
// Revision 1.33  1996/08/08  19:31:37  quinn
// fake_srom_clk now generated off falling-edge of srom clk
//
// Revision 1.32  1996/08/02  15:47:43  quinn
// disabled c_mtv_cfg->shift_valid when fake SROM is enabled
//
// Revision 1.31  1996/07/30  19:55:34  quinn
// expanded and cleaned-up the fake_srom fill path
//
// Revision 1.30  1996/07/29  19:54:16  razdan
// add in some clk_fwd stuff
//
// Revision 1.29  1996/07/28  19:02:45  quinn
// fix random init bug in mtv_cfg logic
//
// Revision 1.28  1996/07/27  19:10:46  quinn
// added fake_srom fill path
//
// Revision 1.27  1996/07/20  16:31:36  razdan
// add in decoded frame_sel
//
// Revision 1.26  1996/07/10  11:43:48  quinn
// activated csr/ipr shift chains
//
// Revision 1.24  1996/07/06  01:22:28  razdan
// add cbox_debug port mux control bits
//
// Revision 1.23  1996/07/03  22:43:34  huggins
// added OR logic to prevent a illegal BCACHE size from being sent
// to the rest of the cbox
//
// Revision 1.22  1996/06/30  15:49:06  huggins
// added MTV config stuff
//
// Revision 1.20  1996/06/21  20:45:07  huggins
// fixed MBOX connection bug, resize write_many, added constants
//
// Revision 1.19  1996/06/13  00:15:54  razdan
// Add shift register.. cleanup csr stuff
//
// Revision 1.18  1996/04/17  02:28:53  razdan
// add csr flop for stc enable
//
// Revision 1.17  1996/04/14  23:12:15  razdan
// c_reg_csr --> extend sysbus_ack_limit_a to five bits..
//
// Revision 1.16  1996/02/24  00:35:53  razdan
// prune csrs
//
// Revision 1.15  1996/01/18  13:43:42  razdan
// remove mem_lat_data_pattern_a
//
// Revision 1.14  1995/12/11  22:42:33  razdan
// increase late-write number
//
// Revision 1.13  1995/12/03  23:29:23  razdan
// add early address csr
//
// Revision 1.12  1995/12/02  20:28:20  razdan
// clean up csrs
//
// Revision 1.11  1995/09/15  21:24:13  razdan
// updated zeroblk/set-dirty enable iprs
//
// Revision 1.10  1995/08/28  20:03:49  mikulis
// Hook up c_reg_csr->sysbus_ack_limit_a
//
// Revision 1.9  1995/08/07  14:31:11  razdan
// remove unneeded CSRs
//
// Revision 1.8  1995/06/20  15:30:33  razdan
// Update the size of bc_rd_wr_bubbles by two bits
//
// Revision 1.7  1995/06/14  14:27:12  razdan
// Add Vector Sizes in source code
//
// Revision 1.6  1995/06/09  20:40:21  razdan
// Added new csr for Seperate System Clock
//
// Revision 1.5  1995/06/03  16:13:55  razdan
// Add system clock load vector csr
//
// Revision 1.4  1995/05/18  19:19:42  razdan
// Place CSRs in shift register
//
// Revision 1.3  1995/05/08  11:36:09  razdan
// Added csr's related to wrapping
//
// Revision 1.2  1995/02/27  13:54:28  razdan
// Added Log command for RCS
//
//
// File Name: c_csr.mdl
//
// Author:  Rahul Razdan
//
// This model file contains the signal definitions for the CSR and IPR
// latches and functions.
// 
//		
//	



#ifdef _MXX_RTL


MXX_VERSION("@(#) c_csr.mdl");

#include "c_csr__cnt.hxx"
#include "k__cnt.hxx"
#include "m__cnt.hxx"
#include "c__cnt.hxx"
#include "t__cnt.hxx"
#include "c_abus__cnt.hxx"
#include "c_pads__cnt.hxx"

// A-phase and B-phase Tagged MACROs for the clock field of latches.
#define ACLK  CLK(k->clk)
#define BCLK  CLK(~k->clk)

void DUP_SIG_CHK1(Signal & org_sig, Signal & dup_sig) {
  CHECK(IF(~c->reset_a_h & ~c_reg_ipr->cbox_shift_a_h & (dup_sig != org_sig)),
        MESSAGE(SEV(error),"DUP_SIG_CHK1: duplicate signal mis-match, ",dup_sig.gen_name," != ",org_sig.gen_name," \n"));
}

void DUP_SIG_CHK2(Signal & org_sig, Signal & dup_sig) {
  CHECK(IF(~c->reset_a_h & c_mtv_cfg->write_many_valid_h & (dup_sig != org_sig)),
        MESSAGE(SEV(error),"DUP_SIG_CHK2: duplicate signal mis-match, ",dup_sig.gen_name," != ",org_sig.gen_name," \n"));
}

//  forward calls for various schematic definitions
void csr_build_shift_register();
void    csr_build_old_connects();

void ewl_main()
{
#ifdef CBOX_DEBUG
   csr_build_old_connects();
#endif // DHA
// DHA #else
   csr_build_shift_register();
// DHA #endif 

} // end of ewl_main()


void csr_build_old_connects()
{


  c_reg_csr->bc_burst_mode_enable_a		= c_csr->bc_burst_mode_enable;
  c_reg_csr->bc_clean_victim_a(0,0) 		= c_csr->bc_clean_victim(0,0);	  	
// DHA  c_reg_csr->bc_clean_victim_b(0,0) 		= c_csr->bc_clean_victim(0,0);	  	
// DHA   c_reg_csr->bc_enable_b(0,0) 			= c_csr->bc_enable(0,0);	  	
  c_reg_csr->bc_enable_a(0,0) 			= c_csr->bc_enable(0,0);	  	
  c_reg_csr->bc_rd_rd_bubbles_a(1,0) 		= c_csr->bc_rd_rd_bubbles(1,0);  	
  c_reg_csr->bc_rd_wr_bubbles_a(5,0) 		= c_csr->bc_rd_wr_bubbles(5,0);  	
  c_reg_csr->bc_rdclk_ld_vector_a(15,0) 	= c_csr->bc_rdclk_ld_vector(15,0); 		
  c_reg_csr->sys_add_clk_ld_vector_a(15,0) 	= c_csr->sys_add_clk_ld_vector(15,0); 		
  c_reg_csr->bc_rdvictim_a(0,0) 		= c_csr->bc_rdvictim;	  	
// DHA  c_reg_csr->bc_size_b(4,1)	 		= c_csr->bc_size(4,1);	 	  	// don't really need both
  c_reg_csr->bc_size_a(4,1)	 		= c_csr->bc_size(4,1);	 	  	// csr's do not change
  c_reg_csr->bch_readclk_ratio_a(15,0)      	= c_csr->bch_readclk_ratio(15,0);	
  c_reg_csr->dcvic_threshold_a(7,0) 		= c_csr->dcvic_threshold(7,0);	
  c_reg_csr->dup_tag_enable_a(0,0) 		= c_csr->dup_tag_enable(0,0);	  	
  c_reg_csr->set_dirty_enable_a			= c_csr->set_dirty_enable;	
  c_reg_csr->enable_stc_command_a		= c_csr->enable_stc_command;	
  c_reg_csr->sysbus_format_a      		= c_csr->sysbus_format;	  	
  c_reg_csr->sysbus_mb_enable_a(0,0)   		= c_csr->sysbus_mb_enable(0,0);  	
  c_reg_csr->sysbus_ack_limit_a(4,0)	        = c_csr->sysbus_ack_limit(4,0);
  c_reg_csr->zeroblk_enable_a(1,0)		= c_csr->zeroblk_enable;	
  c_reg_csr->bc_late_write_num_a(2,0)	  	= c_csr->bc_late_write_num(2,0);	  	   // will be used
  c_reg_csr->bc_cpu_late_write_num_a(1,0)	= c_csr->bc_cpu_late_write_num(1,0); 	   // will be used
  c_reg_csr->tlaser_stio_mode_a			= c_csr->tlaser_stio_mode;	  	   // will be used
  c_reg_csr->add_sys_sysclk_ratio_a(15,0)   	= c_csr->add_sys_sysclk_ratio(15,0);
// DHA   c_reg_ipr->cbox_shiftdone_a_h	                = c_pad_msc->reset_12a & ~c_pad_msc->reset_11a;

// DHA  c_reg_csr->frame_select_dec_a	= DECODER(IN(c_reg_csr->frame_select_a));

}




/*
        The story on CBOX IPRs....


        1. There are there IPRs
			WRITE ONCE --> from SROM port
			WRITE MANY --> from MBOX IPR CBOX write port
			READ  ONCE --> from MBOX IPR CBOX read port
        2. The MBOX will take care of "retire" logic etc.. just like it does for its other IPRs



*/


void csr_build_shift_register()
{
int i, j;
//	CBOX WRITE ONCE and WRITE MANY chains
//
// NOTE: Changing these may require DVT environment changes. See table below:
//        1) csr position changes  -------  No changes needed. Just change constant.
//        2) Duplicate csr's       -------  Only need to change function in verif_utils.cxx
//        3) Delete csr            -------  Only need to change function in verif_utils.cxx and tell Jim.
//        4) Change csr bit size   -------  Change verif_utils.cxx and will need env rebuild (Jim)
//	  5) Add a new csr         -------  Change verif_utils.cxx and will need env rebuild (Jim)
//	 (look at code in verif_utils.cxx -- function set_cbox_config()) 

c_reg_csr->frame_select_dec_a	= DECODER(IN(c_reg_csr->frame_select_a));
c->tlaser_io_mode_a             = c_reg_csr->tlaser_stio_mode_a;         // send to mbox
// DHA Don't drive CSRs with write_once chain to allow Xbox.cxx code to override values for CBOX_DEBUG
// DHA Don't drive CSRs with write_many chain because there is no CBOX_DEBUG method to write them.
#ifndef CBOX_DEBUG

//	CBOX WRITE ONCE chain
//
j = 0;
// C_IOA_VLD
for( i=0  ; i < 1  ; i++,j++)	{ c_reg_csr->tlaser_stio_mode_a				= c_reg_ipr->write_once_a(j);	}
for( i=1  ; i < 2  ; i++,j++)	{ c_reg_csr->bc_clk_ratio_a(i)				= c_reg_ipr->write_once_a(j);	}
// C_VAF_VIC
for( i=0  ; i < 1  ; i++,j++)	{ c->skewed_fill_mode_a_h				= c_reg_ipr->write_once_a(j);	}
for( i=0  ; i < 8  ; i++,j++)	{ c_reg_csr->dcvic_threshold_a(i)			= c_reg_ipr->write_once_a(j);	}
// C_ADC_BCT
for( i=0  ; i < 1  ; i++,j++)	{ c_reg_csr->bc_clean_victim_a				= c_reg_ipr->write_once_a(j);	}
// C_ADC_SMX
for( i=0  ; i < 2  ; i++,j++)	{ c_reg_csr->sys_bus_size_a(i)				= c_reg_ipr->write_once_a(j);	}
for( i=0  ; i < 1  ; i++,j++)	{ c_reg_csr->sysbus_format_a				= c_reg_ipr->write_once_a(j);	}
for( i=1  ; i < 5  ; i++,j++)	{ c_reg_csr->sys_clk_ratio_a(i)				= c_reg_ipr->write_once_a(j);	}
// C_PRQ_ACT
for( i=0  ; i < 1  ; i++,j++)	{ c_reg_csr->dup_tag_enable_a				= c_reg_ipr->write_once_a(j);	}
for( i=0  ; i < 1  ; i++,j++)	{ c_reg_csr->prb_tag_only_a				= c_reg_ipr->write_once_a(j);	}
// C_SYS_ARO
for( i=0  ; i < 1  ; i++,j++)	{ c_reg_csr->fast_mode_disable_a			= c_reg_ipr->write_once_a(j);	}
for( i=0  ; i < 1  ; i++,j++)	{ c_reg_csr->bc_rdvictim_a				= c_reg_ipr->write_once_a(j);	}
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK1(c_reg_csr->bc_clean_victim_a,		  c_reg_ipr->write_once_a(j));	}
for( i=0  ; i < 1  ; i++,j++)	{ c_reg_csr->rdvic_ack_inhibit_a			= c_reg_ipr->write_once_a(j);	}
for( i=0  ; i < 1  ; i++,j++)	{ c_reg_csr->sysbus_mb_enable_a				= c_reg_ipr->write_once_a(j);	}
// C_SYS_CNT
for( i=4  ; i >= 0 ; i--,j++)	{ c_reg_csr->sysbus_ack_limit_a(i)			= c_reg_ipr->write_once_a(j);	}
for( i=2  ; i >= 0 ; i--,j++)	{ c_reg_csr->sysbus_vic_limit_a(i)			= c_reg_ipr->write_once_a(j);	}
// C_ADC_TAG
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK1(c_reg_csr->bc_clean_victim_a,		  c_reg_ipr->write_once_a(j));	}
// C_BCC_ALC
for( i=5  ; i >= 0 ; i--,j++)	{ c_reg_csr->bc_rd_wr_bubbles_a(i)			= c_reg_ipr->write_once_a(j);	}
for( i=0  ; i <  1 ; i++,j++)	{ c_reg_csr->bc_rd_rd_bubble_a(i)			= c_reg_ipr->write_once_a(j);	}
for( i=0  ; i <  1 ; i++,j++)	{ c_reg_csr->bc_wr_wr_bubble_a(i)			= c_reg_ipr->write_once_a(j);	}
for( i=3  ; i >= 0 ; i--,j++)	{ c_reg_csr->bc_wr_rd_bubbles_a(i)			= c_reg_ipr->write_once_a(j);	}
// C_ISB_CT6
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK1(c_reg_csr->dup_tag_enable_a,		  c_reg_ipr->write_once_a(j));	}
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK1(c->skewed_fill_mode_a_h,			  c_reg_ipr->write_once_a(j));	}

// C_ISB_CT4
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK1(c_reg_csr->bc_rdvictim_a,		  c_reg_ipr->write_once_a(j));	}
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK1(c->skewed_fill_mode_a_h,			  c_reg_ipr->write_once_a(j));	}
// C_ISB_CT3
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK1(c_reg_csr->bc_rdvictim_a,		  c_reg_ipr->write_once_a(j));	}
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK1(c_reg_csr->bc_clean_victim_a,		  c_reg_ipr->write_once_a(j));	}
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK1(c_reg_csr->dup_tag_enable_a,		  c_reg_ipr->write_once_a(j));	}
// C_ISB_CT2
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK1(c->skewed_fill_mode_a_h,			  c_reg_ipr->write_once_a(j));	}
// C_ISB_CT1
for( i=0  ; i < 1  ; i++,j++)	{ c_reg_csr->spec_read_enable_a				= c_reg_ipr->write_once_a(j);	}
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK1(c->skewed_fill_mode_a_h,			  c_reg_ipr->write_once_a(j));	}
// C_BCS_CT0
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK1(c->skewed_fill_mode_a_h,			  c_reg_ipr->write_once_a(j));	}
// C_VAF_DCE/C_BCS_BMP
for( i=0  ; i < 1  ; i++,j++)	{ c_reg_csr->mbox_bc_prb_stall_a                        = c_reg_ipr->write_once_a(j);	}
for( i=31 ; i >= 0 ; i--,j++)	{ c_reg_csr->bc_lat_data_pattern_a(i)			= c_reg_ipr->write_once_a(j);	}
// C_BCS_BMP
for( i=23 ; i >= 0 ; i--,j++)	{ c_reg_csr->bc_lat_tag_pattern_a(i)			= c_reg_ipr->write_once_a(j);	}
// C_CMF_CTN
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK1(c_reg_csr->bc_rdvictim_a,		  c_reg_ipr->write_once_a(j));	}
for( i=0  ; i < 1  ; i++,j++)	{ c_reg_csr->enable_stc_command_a			= c_reg_ipr->write_once_a(j);	}
// C_BCW_BCS
for( i=2  ; i >= 0 ; i--,j++)	{ c_reg_csr->bc_late_write_num_a(i)			= c_reg_ipr->write_once_a(j);	}
for( i=1  ; i >= 0 ; i--,j++)	{ c_reg_csr->bc_cpu_late_write_num_a(i)			= c_reg_ipr->write_once_a(j);	}
for( i=0  ; i < 1  ; i++,j++)	{ c_reg_csr->bc_burst_mode_enable_a			= c_reg_ipr->write_once_a(j);	}
for( i=0  ; i < 1  ; i++,j++)	{ c_reg_csr->bc_pentium_mode_a				= c_reg_ipr->write_once_a(j);	}
for( i=1  ; i < 2  ; i++,j++)	{ DUP_SIG_CHK1(c_reg_csr->bc_clk_ratio_a(i),		  c_reg_ipr->write_once_a(j));	}
for( i=0  ; i < 1  ; i++,j++)	{ c_reg_csr->bc_frm_clk_a				= c_reg_ipr->write_once_a(j);	}
// C_BIX_PAD/C_BTG_PAD
for( i=1  ; i >= 0 ; i--,j++)	{ c_reg_csr->bc_clk_delay_a(i)				= c_reg_ipr->write_once_a(j);	}
for( i=0  ; i < 1  ; i++,j++)	{ c_reg_csr->bc_ddmr_enable_a				= c_reg_ipr->write_once_a(j);	}
for( i=0  ; i < 1  ; i++,j++)	{ c_reg_csr->bc_ddmf_enable_a				= c_reg_ipr->write_once_a(j);	}
for( i=0  ; i < 1  ; i++,j++)	{ c_reg_csr->bc_late_write_upper_a			= c_reg_ipr->write_once_a(j);	}
for( i=0  ; i < 1  ; i++,j++)	{ c_reg_csr->bc_tag_ddm_fall_en_a			= c_reg_ipr->write_once_a(j);	}
for( i=0  ; i < 1  ; i++,j++)	{ c_reg_csr->bc_tag_ddm_rise_en_a			= c_reg_ipr->write_once_a(j);	}
for( i=0  ; i < 1  ; i++,j++)	{ c_reg_csr->bc_clkfwd_enable_a				= c_reg_ipr->write_once_a(j);	}
for( i=1  ; i >= 0 ; i--,j++)	{ c_reg_csr->bc_rcv_mux_cnt_preset_a(i)			= c_reg_ipr->write_once_a(j);	}
for( i=0  ; i < 1  ; i++,j++)	{ c_reg_csr->bc_tag_ddm_rd_fall_en_a			= c_reg_ipr->write_once_a(j);	}
for( i=0  ; i < 1  ; i++,j++)	{ c_reg_csr->bc_tag_ddm_rd_rise_en_a		  	= c_reg_ipr->write_once_a(j);	}
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK1(c_reg_csr->bc_late_write_upper_a,	  c_reg_ipr->write_once_a(j));	}
// C_BNW_PAD/C_BNE_PAD
for( i=0  ; i < 1  ; i++,j++)	{ c_reg_csr->sys_ddm_fall_en_a				= c_reg_ipr->write_once_a(j);	}
for( i=0  ; i < 1  ; i++,j++)	{ c_reg_csr->sys_ddm_rise_en_a				= c_reg_ipr->write_once_a(j);	}
for( i=0  ; i < 1  ; i++,j++)	{ c_reg_csr->sys_clkfwd_enable_a			= c_reg_ipr->write_once_a(j);	}
for( i=1  ; i >= 0 ; i--,j++)	{ c_reg_csr->sys_rcv_mux_cnt_preset_a(i)		= c_reg_ipr->write_once_a(j);	}
for( i=0  ; i < 1  ; i++,j++)	{ c_reg_csr->sys_ddm_rd_fall_en_a			= c_reg_ipr->write_once_a(j);	}
for( i=0  ; i < 1  ; i++,j++)	{ c_reg_csr->sys_ddm_rd_rise_en_a			= c_reg_ipr->write_once_a(j);	}
for( i=1  ; i >= 0 ; i--,j++)	{ c_reg_csr->sys_clk_delay_a(i)				= c_reg_ipr->write_once_a(j);	}
for( i=0  ; i < 1  ; i++,j++)	{ c_reg_csr->sys_ddmr_enable_a				= c_reg_ipr->write_once_a(j);	}
for( i=0  ; i < 1  ; i++,j++)	{ c_reg_csr->sys_ddmf_enable_a				= c_reg_ipr->write_once_a(j);	}
for( i=0  ; i < 1  ; i++,j++)	{ c_reg_csr->bc_ddm_fall_en_a				= c_reg_ipr->write_once_a(j);	}
for( i=0  ; i < 1  ; i++,j++)	{ c_reg_csr->bc_ddm_rise_en_a		  		= c_reg_ipr->write_once_a(j);	}
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK1(c_reg_csr->bc_clkfwd_enable_a,		  c_reg_ipr->write_once_a(j));	}
for( i=1  ; i >= 0 ; i--,j++)	{ DUP_SIG_CHK1(c_reg_csr->bc_rcv_mux_cnt_preset_a(i),	  c_reg_ipr->write_once_a(j));	}
for( i=0  ; i < 1  ; i++,j++)	{ c_reg_csr->bc_ddm_rd_fall_en_a		  	= c_reg_ipr->write_once_a(j);	}
for( i=0  ; i < 1  ; i++,j++)	{ c_reg_csr->bc_ddm_rd_rise_en_a		  	= c_reg_ipr->write_once_a(j);	}
// C_BWN_PAD/C_BEN_PAD
for( i=1  ; i >= 0 ; i--,j++)	{ DUP_SIG_CHK1(c_reg_csr->bc_clk_delay_a(i),		  c_reg_ipr->write_once_a(j));	}
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK1(c_reg_csr->bc_ddmr_enable_a,		  c_reg_ipr->write_once_a(j));	}
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK1(c_reg_csr->bc_ddmf_enable_a,		  c_reg_ipr->write_once_a(j));	}
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK1(c_reg_csr->sys_ddm_fall_en_a,		  c_reg_ipr->write_once_a(j));	}
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK1(c_reg_csr->sys_ddm_rise_en_a,		  c_reg_ipr->write_once_a(j));	}
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK1(c_reg_csr->sys_clkfwd_enable_a,		  c_reg_ipr->write_once_a(j));	}
for( i=1  ; i >= 0 ; i--,j++)	{ DUP_SIG_CHK1(c_reg_csr->sys_rcv_mux_cnt_preset_a(i),	  c_reg_ipr->write_once_a(j));	}
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK1(c_reg_csr->sys_ddm_rd_fall_en_a,		  c_reg_ipr->write_once_a(j));	}
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK1(c_reg_csr->sys_ddm_rd_rise_en_a,		  c_reg_ipr->write_once_a(j));	}
for( i=1  ; i >= 0 ; i--,j++)	{ DUP_SIG_CHK1(c_reg_csr->sys_clk_delay_a(i),		  c_reg_ipr->write_once_a(j));	}
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK1(c_reg_csr->sys_ddmr_enable_a,		  c_reg_ipr->write_once_a(j));	}
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK1(c_reg_csr->sys_ddmf_enable_a,		  c_reg_ipr->write_once_a(j));	}
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK1(c_reg_csr->bc_ddm_fall_en_a,		  c_reg_ipr->write_once_a(j));	}
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK1(c_reg_csr->bc_ddm_rise_en_a,		  c_reg_ipr->write_once_a(j));	}
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK1(c_reg_csr->bc_clkfwd_enable_a,		  c_reg_ipr->write_once_a(j));	}
for( i=1  ; i >= 0 ; i--,j++)	{ DUP_SIG_CHK1(c_reg_csr->bc_rcv_mux_cnt_preset_a(i),	  c_reg_ipr->write_once_a(j));	}
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK1(c_reg_csr->bc_ddm_rd_fall_en_a,		  c_reg_ipr->write_once_a(j));	}
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK1(c_reg_csr->bc_ddm_rd_rise_en_a,		  c_reg_ipr->write_once_a(j));	}
// C_BWS_PAD/C_BES_PAD
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK1(c_reg_csr->sys_ddm_fall_en_a,		  c_reg_ipr->write_once_a(j));	}
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK1(c_reg_csr->sys_ddm_rise_en_a,		  c_reg_ipr->write_once_a(j));	}
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK1(c_reg_csr->sys_clkfwd_enable_a,		  c_reg_ipr->write_once_a(j));	}
for( i=1  ; i >= 0 ; i--,j++)	{ DUP_SIG_CHK1(c_reg_csr->sys_rcv_mux_cnt_preset_a(i),	  c_reg_ipr->write_once_a(j));	}
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK1(c_reg_csr->sys_ddm_rd_fall_en_a,		  c_reg_ipr->write_once_a(j));	}
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK1(c_reg_csr->sys_ddm_rd_rise_en_a,		  c_reg_ipr->write_once_a(j));	}
for( i=1  ; i >= 0 ; i--,j++)	{ DUP_SIG_CHK1(c_reg_csr->sys_clk_delay_a(i),		  c_reg_ipr->write_once_a(j));	}
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK1(c_reg_csr->sys_ddmr_enable_a,		  c_reg_ipr->write_once_a(j));	}
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK1(c_reg_csr->sys_ddmf_enable_a,		  c_reg_ipr->write_once_a(j));	}
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK1(c_reg_csr->bc_ddm_fall_en_a,		  c_reg_ipr->write_once_a(j));	}
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK1(c_reg_csr->bc_ddm_rise_en_a,		  c_reg_ipr->write_once_a(j));	}
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK1(c_reg_csr->bc_clkfwd_enable_a,		  c_reg_ipr->write_once_a(j));	}
for( i=1  ; i >= 0 ; i--,j++)	{ DUP_SIG_CHK1(c_reg_csr->bc_rcv_mux_cnt_preset_a(i),	  c_reg_ipr->write_once_a(j));	}
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK1(c_reg_csr->bc_ddm_rd_fall_en_a,		  c_reg_ipr->write_once_a(j));	}
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK1(c_reg_csr->bc_ddm_rd_rise_en_a,		  c_reg_ipr->write_once_a(j));	}
// C_BSW_PAD/C_BSE_PAD
for( i=1  ; i >= 0 ; i--,j++)	{ DUP_SIG_CHK1(c_reg_csr->bc_clk_delay_a(i),		  c_reg_ipr->write_once_a(j));	}
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK1(c_reg_csr->bc_ddmr_enable_a,		  c_reg_ipr->write_once_a(j));	}
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK1(c_reg_csr->bc_ddmf_enable_a,		  c_reg_ipr->write_once_a(j));	}
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK1(c_reg_csr->sys_ddm_fall_en_a,		  c_reg_ipr->write_once_a(j));	}
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK1(c_reg_csr->sys_ddm_rise_en_a,		  c_reg_ipr->write_once_a(j));	}
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK1(c_reg_csr->sys_clkfwd_enable_a,		  c_reg_ipr->write_once_a(j));	}
for( i=1  ; i >= 0 ; i--,j++)	{ DUP_SIG_CHK1(c_reg_csr->sys_rcv_mux_cnt_preset_a(i),	  c_reg_ipr->write_once_a(j));	}
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK1(c_reg_csr->sys_ddm_rd_fall_en_a,		  c_reg_ipr->write_once_a(j));	}
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK1(c_reg_csr->sys_ddm_rd_rise_en_a,		  c_reg_ipr->write_once_a(j));	}
for( i=1  ; i >= 0 ; i--,j++)	{ DUP_SIG_CHK1(c_reg_csr->sys_clk_delay_a(i),		  c_reg_ipr->write_once_a(j));	}
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK1(c_reg_csr->sys_ddmr_enable_a,		  c_reg_ipr->write_once_a(j));	}
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK1(c_reg_csr->sys_ddmf_enable_a,		  c_reg_ipr->write_once_a(j));	}
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK1(c_reg_csr->bc_ddm_fall_en_a,		  c_reg_ipr->write_once_a(j));	}
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK1(c_reg_csr->bc_ddm_rise_en_a,		  c_reg_ipr->write_once_a(j));	}
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK1(c_reg_csr->bc_clkfwd_enable_a,		  c_reg_ipr->write_once_a(j));	}
for( i=1  ; i >= 0 ; i--,j++)	{ DUP_SIG_CHK1(c_reg_csr->bc_rcv_mux_cnt_preset_a(i),	  c_reg_ipr->write_once_a(j));	}
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK1(c_reg_csr->bc_ddm_rd_fall_en_a,		  c_reg_ipr->write_once_a(j));	}
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK1(c_reg_csr->bc_ddm_rd_rise_en_a,		  c_reg_ipr->write_once_a(j));	}
// C_BSO_PAD
for( i=1  ; i >= 0 ; i--,j++)	{ DUP_SIG_CHK1(c_reg_csr->sys_clk_delay_a(i),		  c_reg_ipr->write_once_a(j));	}
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK1(c_reg_csr->sys_ddmr_enable_a,		  c_reg_ipr->write_once_a(j));	}
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK1(c_reg_csr->sys_ddmf_enable_a,		  c_reg_ipr->write_once_a(j));	}
// C_BSI_PAD
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK1(c_reg_csr->sys_ddm_fall_en_a,		  c_reg_ipr->write_once_a(j));	}
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK1(c_reg_csr->sys_ddm_rise_en_a,		  c_reg_ipr->write_once_a(j));	}
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK1(c_reg_csr->sys_clkfwd_enable_a,		  c_reg_ipr->write_once_a(j));	}
for( i=1  ; i >= 0 ; i--,j++)	{ DUP_SIG_CHK1(c_reg_csr->sys_rcv_mux_cnt_preset_a(i),	  c_reg_ipr->write_once_a(j));	}
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK1(c_reg_csr->sys_ddm_rd_fall_en_a,		  c_reg_ipr->write_once_a(j));	}
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK1(c_reg_csr->sys_ddm_rd_rise_en_a,		  c_reg_ipr->write_once_a(j));	}
// C_BRS_CFR
for( i=2  ; i >= 0 ; i--,j++)	{ c_reg_csr->cfr_gclk_delay_a(i)			= c_reg_ipr->write_once_a(j);	}
for( i=2  ; i >= 0 ; i--,j++)	{ c_reg_csr->cfr_ev6clk_delay_a(i)			= c_reg_ipr->write_once_a(j);	}
for( i=1  ; i >= 0 ; i--,j++)	{ c_reg_csr->cfr_frmclk_delay_a(i)			= c_reg_ipr->write_once_a(j);	}
// C_OSB_CT1
for( i=2  ; i >= 0 ; i--,j++)	{ DUP_SIG_CHK1(c_reg_csr->bc_late_write_num_a(i),	  c_reg_ipr->write_once_a(j));	}
for( i=0  ; i < 2  ; i++,j++)	{ DUP_SIG_CHK1(c_reg_csr->bc_cpu_late_write_num_a(i),	  c_reg_ipr->write_once_a(j));	}
// C_OSB_CT2
for( i=0  ; i < 1  ; i++,j++)	{ c_reg_csr->jitter_cmd_a				= c_reg_ipr->write_once_a(j);	}
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK1(c_reg_csr->fast_mode_disable_a,		  c_reg_ipr->write_once_a(j));	}
// C_OSB_ARB
for( i=0  ; i < 4  ; i++,j++)	{ c_reg_csr->sysdc_delay_a(i)				= c_reg_ipr->write_once_a(j);	}
for( i=0  ; i < 2  ; i++,j++)	{ c_reg_csr->data_valid_dly_a(i)			= c_reg_ipr->write_once_a(j);	}
// C_CLK_BCA
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK1(c_reg_csr->bc_ddm_fall_en_a,		  c_reg_ipr->write_once_a(j));	}
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK1(c_reg_csr->bc_ddm_rise_en_a,		  c_reg_ipr->write_once_a(j));	}
for( i=1  ; i >= 0 ; i--,j++)	{ c_reg_csr->bc_cpu_clk_delay_a(i)			= c_reg_ipr->write_once_a(j);	}
for( i=7  ; i >= 0 ; i--,j++)	{ c_reg_csr->bc_fdbk_en_a(i)				= c_reg_ipr->write_once_a(j);	}
for( i=15 ; i >= 0 ; i--,j++)	{ c_reg_csr->bc_clk_ld_vector_a(i)			= c_reg_ipr->write_once_a(j);	}
for( i=3  ; i >= 0 ; i--,j++)	{ c_reg_csr->bc_bphase_ld_vector_a(i)			= c_reg_ipr->write_once_a(j);	}
// C_CLK_SYS
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK1(c_reg_csr->sys_ddm_fall_en_a,		  c_reg_ipr->write_once_a(j));	}
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK1(c_reg_csr->sys_ddm_rise_en_a,		  c_reg_ipr->write_once_a(j));	}
for( i=1  ; i >= 0 ; i--,j++)	{ c_reg_csr->sys_cpu_clk_delay_a(i)			= c_reg_ipr->write_once_a(j);	}
for( i=7  ; i >= 0 ; i--,j++)	{ c_reg_csr->sys_fdbk_en_a(i)				= c_reg_ipr->write_once_a(j);	}
for( i=15 ; i >= 0 ; i--,j++)	{ c_reg_csr->sys_clk_ld_vector_a(i)			= c_reg_ipr->write_once_a(j);	}
for( i=3  ; i >= 0 ; i--,j++)	{ c_reg_csr->sys_bphase_ld_vector_a(i)			= c_reg_ipr->write_once_a(j);	}
for( i=4  ; i >= 0 ; i--,j++)	{ c_reg_csr->sys_frame_ld_vector_a(i)			= c_reg_ipr->write_once_a(j);	}
// additional old signals
for( i=0  ; i < 2  ; i++,j++)	{ c_reg_csr->frame_select_a(i)				= c_reg_ipr->write_once_a(j);	} 
for( i=0  ; i < 1  ; i++,j++)	{ c_reg_csr->bc_cf_double_clk_a				= c_reg_ipr->write_once_a(j);	}
for( i=0  ; i < 1  ; i++,j++)	{ c_reg_csr->sys_cf_double_clk_a			= c_reg_ipr->write_once_a(j);	}
for( i=0  ; i < 1  ; i++,j++)	{ c_reg_csr->bc_clk_ratio_a(i)				= c_reg_ipr->write_once_a(j);	}
for( i=2  ; i < 16 ; i++,j++)	{ c_reg_csr->bc_clk_ratio_a(i)				= c_reg_ipr->write_once_a(j);	}
for( i=0  ; i < 1  ; i++,j++)	{ c_reg_csr->sys_clk_ratio_a(i)				= c_reg_ipr->write_once_a(j);	}
for( i=5  ; i < 16 ; i++,j++)	{ c_reg_csr->sys_clk_ratio_a(i)				= c_reg_ipr->write_once_a(j);	}

//	CBOX WRITE MANY chain
//
j = 0;
for( i=0  ; i < 1  ; i++,j++)	{ c_reg_csr->bc_enable_a				= c_reg_ipr->write_many_a(j);	}
for( i=0  ; i < 1  ; i++,j++)	{ c_reg_csr->init_mode_a				= c_reg_ipr->write_many_a(j);	}
for( i=1  ; i < 5  ; i++,j++)	{ c_reg_csr->raw_bc_size_a(i)				= c_reg_ipr->write_many_a(j);	}
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK2(c_reg_csr->bc_enable_a,			  c_reg_ipr->write_many_a(j));	}
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK2(c_reg_csr->bc_enable_a,			  c_reg_ipr->write_many_a(j));	}
for( i=4  ; i >= 1 ; i--,j++)	{ DUP_SIG_CHK2(c_reg_csr->raw_bc_size_a(i),		  c_reg_ipr->write_many_a(j));	}
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK2(c_reg_csr->bc_enable_a,			  c_reg_ipr->write_many_a(j));	}
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK2(c_reg_csr->bc_enable_a,			  c_reg_ipr->write_many_a(j));	}
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK2(c_reg_csr->bc_enable_a,			  c_reg_ipr->write_many_a(j));	}
for( i=1  ; i < 2  ; i++,j++)	{ c_reg_csr->zeroblk_enable_a(i)			= c_reg_ipr->write_many_a(j);	}
for( i=0  ; i < 1  ; i++,j++)	{ c_reg_csr->enable_evict_a				= c_reg_ipr->write_many_a(j);	}
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK2(c_reg_csr->bc_enable_a,			  c_reg_ipr->write_many_a(j));	}
for( i=0  ; i < 1  ; i++,j++)	{ c_reg_csr->zeroblk_enable_a(i)			= c_reg_ipr->write_many_a(j);	}
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK2(c_reg_csr->bc_enable_a,			  c_reg_ipr->write_many_a(j));	}
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK2(c_reg_csr->bc_enable_a,			  c_reg_ipr->write_many_a(j));	}
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK2(c_reg_csr->bc_enable_a,			  c_reg_ipr->write_many_a(j));	}
for( i=0  ; i < 1  ; i++,j++)	{ c_reg_csr->set_dirty_enable_a(i)			= c_reg_ipr->write_many_a(j);	}
for( i=0  ; i < 1  ; i++,j++)	{ DUP_SIG_CHK2(c_reg_csr->zeroblk_enable_a(i),		  c_reg_ipr->write_many_a(j));	}
for( i=1  ; i < 3  ; i++,j++)	{ c_reg_csr->set_dirty_enable_a(i)			= c_reg_ipr->write_many_a(j);	}
for( i=0  ; i < 1  ; i++,j++)	{ c_reg_csr->bc_bank_enable_a				= c_reg_ipr->write_many_a(j);	}
for( i=4  ; i >= 1 ; i--,j++)	{ c_reg_csr->pad_raw_bc_size_a(i)                       = c_reg_ipr->write_many_a(j);	}
for( i=0  ; i < 1  ; i++,j++)	{ c_reg_csr->init_mode_2_a(i)          			=  c_reg_ipr->write_many_a(j);	}
for( i=3  ; i >= 0 ; i--,j++)	{ c_reg_csr->bc_wrt_sts_a(i)				= c_reg_ipr->write_many_a(j);	}

// This forces legal values on the signal used by the rest of the chip.  Note that if illegal values were
// sent out to the rest of the CBOX mux errors would result.
c_reg_csr->bc_size_a(4) =  c_reg_csr->raw_bc_size_a(4);
c_reg_csr->bc_size_a(3) =  c_reg_csr->raw_bc_size_a(4) | c_reg_csr->raw_bc_size_a(3);
c_reg_csr->bc_size_a(2) =  c_reg_csr->raw_bc_size_a(4) | c_reg_csr->raw_bc_size_a(3) | c_reg_csr->raw_bc_size_a(2);
c_reg_csr->bc_size_a(1) =  c_reg_csr->raw_bc_size_a(4) | c_reg_csr->raw_bc_size_a(3) | c_reg_csr->raw_bc_size_a(2) | c_reg_csr->raw_bc_size_a(1);


c_reg_csr->pad_bc_size_a(4) =  c_reg_csr->pad_raw_bc_size_a(4);
c_reg_csr->pad_bc_size_a(3) =  c_reg_csr->pad_raw_bc_size_a(4) | c_reg_csr->pad_raw_bc_size_a(3);
c_reg_csr->pad_bc_size_a(2) =  c_reg_csr->pad_raw_bc_size_a(4) | c_reg_csr->pad_raw_bc_size_a(3) | c_reg_csr->pad_raw_bc_size_a(2);
c_reg_csr->pad_bc_size_a(1) =  c_reg_csr->pad_raw_bc_size_a(4) | c_reg_csr->pad_raw_bc_size_a(3) | c_reg_csr->pad_raw_bc_size_a(2) | c_reg_csr->pad_raw_bc_size_a(1);

#else // defined CBOX_DEBUG

// This is backwards to real schematics, but raw_bc_size is now used in
// parts of c_abus.mdl, and pad_raw_bc_size in c_pads.mdl.  Since we
// don't actually do the shift in the CX model, this shouldn't be an
// issue.
//
c_reg_csr->raw_bc_size_a(4,1) = c_reg_csr->bc_size_a(4,1);
c_reg_csr->pad_raw_bc_size_a(4,1) = c_reg_csr->bc_size_a(4,1);

c_reg_csr->pad_bc_size_a(4,1) = c_reg_csr->bc_size_a(4,1);

#endif

c_reg_ipr->cbox_shift_a_h = DFLOP(ACLK, t->cbox_shift_a_h & t->enable_tbox);

// DHA #if !defined(CBOX_DEBUG) && !defined(REAL_CBOX_CONFIG)
#if !defined(REAL_CBOX_CONFIG)

//	CBOX WRITE ONCE chain
//
c_mtv_cfg->fake_srom_clk_a_h = ~t->pad_srom_clk_a_h & DFLOP( ACLK, t->pad_srom_clk_a_h ) & t->pad_en_srom_a_h & c_mtv_cfg->fake_srom_enable_h;

c_mtv_cfg->cbox_shift_a_h = SWITCH(SEL(~c_mtv_cfg->fake_srom_enable_h),
                                   CASE(0), c_mtv_cfg->fake_srom_clk_a_h,
                                   CASE(1), c_mtv_cfg->shift_valid_a_h(WRITE_ONCE_MSB));

c_mtv_cfg->shift_valid_b_h(WRITE_ONCE_MSB,0) = DLAT(CLK(!k->clk & c_mtv_cfg->cbox_shift_a_h), CONCAT(c_mtv_cfg->shift_valid_a_h(WRITE_ONCE_MSB - 1,0),0));
c_mtv_cfg->shift_data_b_h(WRITE_ONCE_MSB+16,0)  = DLAT(CLK(!k->clk & c_mtv_cfg->cbox_shift_a_h), CONCAT(c_mtv_cfg->shift_data_a_h(WRITE_ONCE_MSB + 15,0),c_mtv_cfg->shift_data_lsb_a_h));

c_mtv_cfg->shift_data_lsb_a_h = SWITCH(SEL(c_mtv_cfg->shift_valid_a_h(WRITE_ONCE_MSB) & ~c_mtv_cfg->fake_srom_enable_h),
				       CASE(0), c_mtv_cfg->fake_srom_icaddr_a_h(0),
		                       CASE(1), c_mtv_cfg->shift_data_a_h(WRITE_ONCE_MSB));

c_mtv_cfg->shift_valid_a_h(WRITE_ONCE_MSB,0) = DLAT(ACLK, c_mtv_cfg->shift_valid_b_h(WRITE_ONCE_MSB,0));
c_mtv_cfg->shift_data_a_h(WRITE_ONCE_MSB+16,0) = DLAT(ACLK, c_mtv_cfg->shift_data_b_h(WRITE_ONCE_MSB+16,0));

c_mtv_cfg->ica_sat_so_a_h = SWITCH(SEL(c_reg_ipr->cbox_shift_a_h),
		                   CASE(0), c_mtv_cfg->shift_data_a_h(WRITE_ONCE_MSB),
				   CASE(1), t->ica_sat_so_a_h);


c_reg_ipr->write_once_a(WRITE_ONCE_MSB,0) = DLAT(ACLK,c_reg_ipr->write_once_b);

// Model CSR chain delay flops in the pad schematics

c_reg_ipr->write_once_select_a                    = c_reg_ipr->cbox_shift_a_h | (c_mtv_cfg->shift_valid_a_h(WRITE_ONCE_MSB) & ~c_mtv_cfg->fake_srom_enable_h);
c_reg_ipr->write_once_select_1a = DFLOP(ACLK, c_reg_ipr->write_once_select_a);
c_reg_ipr->write_once_select_2a = DFLOP(ACLK, c_reg_ipr->write_once_select_1a);
c_reg_ipr->write_once_select_3a = DFLOP(ACLK, c_reg_ipr->write_once_select_2a);
c_reg_ipr->write_once_select_4a = DFLOP(ACLK, c_reg_ipr->write_once_select_3a);

c_reg_ipr->write_once_b(WRITE_ONCE_SEC0_MSB, 0) = 
	DLAT(BCLK,SWITCH(SEL(c_reg_ipr->write_once_select_a),
	                 CASE(0), c_reg_ipr->write_once_a(WRITE_ONCE_SEC0_MSB, 0),
			 CASE(1), CONCAT(c_reg_ipr->write_once_a(WRITE_ONCE_SEC0_MSB-1,0),c_mtv_cfg->ica_sat_so_a_h)));
c_reg_ipr->dly_flop1_a_h = DFLOP(ACLK, c_reg_ipr->write_once_a(WRITE_ONCE_SEC0_MSB));

c_reg_ipr->write_once_b(WRITE_ONCE_SEC1_MSB, WRITE_ONCE_SEC0_MSB+1) = 
	DLAT(BCLK,SWITCH(SEL(c_reg_ipr->write_once_select_1a),
	                 CASE(0), c_reg_ipr->write_once_a(WRITE_ONCE_SEC1_MSB, WRITE_ONCE_SEC0_MSB+1),
			 CASE(1), CONCAT(c_reg_ipr->write_once_a(WRITE_ONCE_SEC1_MSB-1,WRITE_ONCE_SEC0_MSB+1),
					 c_reg_ipr->dly_flop1_a_h)));
c_reg_ipr->dly_flop2_a_h = DFLOP(ACLK, c_reg_ipr->write_once_a(WRITE_ONCE_SEC1_MSB));

c_reg_ipr->write_once_b(WRITE_ONCE_SEC2_MSB, WRITE_ONCE_SEC1_MSB+1) = 
	DLAT(BCLK,SWITCH(SEL(c_reg_ipr->write_once_select_2a),
	                 CASE(0), c_reg_ipr->write_once_a(WRITE_ONCE_SEC2_MSB, WRITE_ONCE_SEC1_MSB+1),
			 CASE(1), CONCAT(c_reg_ipr->write_once_a(WRITE_ONCE_SEC2_MSB-1,WRITE_ONCE_SEC1_MSB+1),
					 c_reg_ipr->dly_flop2_a_h)));
c_reg_ipr->dly_flop3_a_h = DFLOP(ACLK, c_reg_ipr->write_once_a(WRITE_ONCE_SEC2_MSB));

c_reg_ipr->write_once_b(WRITE_ONCE_SEC3_MSB, WRITE_ONCE_SEC2_MSB+1) = 
	DLAT(BCLK,SWITCH(SEL(c_reg_ipr->write_once_select_3a),
	                 CASE(0), c_reg_ipr->write_once_a(WRITE_ONCE_SEC3_MSB, WRITE_ONCE_SEC2_MSB+1),
			 CASE(1), CONCAT(c_reg_ipr->write_once_a(WRITE_ONCE_SEC3_MSB-1,WRITE_ONCE_SEC2_MSB+1),
					 c_reg_ipr->dly_flop3_a_h)));
c_reg_ipr->dly_flop4_a_h = DFLOP(ACLK, c_reg_ipr->write_once_a(WRITE_ONCE_SEC3_MSB));

c_reg_ipr->write_once_b(WRITE_ONCE_MSB, WRITE_ONCE_SEC3_MSB+1) = 
	DLAT(BCLK,SWITCH(SEL(c_reg_ipr->write_once_select_4a),
	                 CASE(0), c_reg_ipr->write_once_a(WRITE_ONCE_MSB, WRITE_ONCE_SEC3_MSB+1),
			 CASE(1), CONCAT(c_reg_ipr->write_once_a(WRITE_ONCE_MSB-1,WRITE_ONCE_SEC3_MSB+1),
					 c_reg_ipr->dly_flop4_a_h)));

c_mtv_cfg->shift_done_dly1_a_h = DFLOP(ACLK,c_mtv_cfg->shift_valid_a_h(WRITE_ONCE_MSB));
c_mtv_cfg->shift_done_dly2_a_h = DFLOP(ACLK,c_mtv_cfg->shift_done_dly1_a_h);
c_mtv_cfg->shift_done_dly3_a_h = DFLOP(ACLK,c_mtv_cfg->shift_done_dly2_a_h);

c_reg_ipr->cbox_shiftdone_a_h = (t->cbox_shiftdone_a_h & t->enable_tbox) | 
                                (c_mtv_cfg->shift_done_dly3_a_h & ~c_mtv_cfg->shift_done_dly2_a_h & ~c_mtv_cfg->fake_srom_enable_h);

c_mtv_cfg->fake_srom_icdata_b_h(SROM_ICDATA_MSB,0) = DLAT(CLK(!k->clk & c_mtv_cfg->fake_srom_clk_a_h), CONCAT(c_mtv_cfg->fake_srom_icdata_a_h(0),c_mtv_cfg->fake_srom_icdata_a_h(SROM_ICDATA_MSB,1)));
c_mtv_cfg->fake_srom_icaddr_b_h(SROM_ICADDR_MSB,0) = DLAT(CLK(!k->clk & c_mtv_cfg->fake_srom_clk_a_h), CONCAT(c_mtv_cfg->fake_srom_icdata_a_h(0),c_mtv_cfg->fake_srom_icaddr_a_h(SROM_ICADDR_MSB,1)));

c_mtv_cfg->fake_srom_icdata_a_h(SROM_ICDATA_MSB,0) = DLAT(ACLK, c_mtv_cfg->fake_srom_icdata_b_h(SROM_ICDATA_MSB,0));
c_mtv_cfg->fake_srom_icaddr_a_h(SROM_ICADDR_MSB,0) = DLAT(ACLK, c_mtv_cfg->fake_srom_icaddr_b_h(SROM_ICADDR_MSB,0));

c_mtv_cfg->fake_srom_data_h = c_mtv_cfg->shift_data_a_h(WRITE_ONCE_MSB+16) & c_mtv_cfg->fake_srom_enable_h;

//	CBOX WRITE MANY chain
//
c_mtv_cfg->write_many_b(WRITE_MANY_MSB,0)  = DLAT(BCLK,SWITCH(SEL(c->reset_a_h & ~c_mtv_cfg->undelayed_write_many_valid_h),
					CASE(0), c_mtv_cfg->write_many_a(WRITE_MANY_MSB,0),
					CASE(1), CONCAT(c_mtv_cfg->write_many_a(WRITE_MANY_MSB - 1,0),
                                                        c_mtv_cfg->write_many_a(WRITE_MANY_MSB))));
c_mtv_cfg->write_many_a(WRITE_MANY_MSB,0)  = DLAT(ACLK,c_mtv_cfg->write_many_b(WRITE_MANY_MSB,0));

c_reg_ipr->write_many_shift_a  = DFLOP(ACLK, m->cbox_ipr_out_val_8a_h);
c_reg_ipr->write_many_shift_1a = DFLOP(ACLK, c_reg_ipr->write_many_shift_a);

c_reg_ipr->write_many_b(WRITE_MANY_SEC0_MSB,0) = 
				    DLAT(BCLK,SWITCH(SEL((~c->reset_a_h & c_reg_ipr->write_many_shift_a) |
                                                         ( c->reset_a_h & ~c_mtv_cfg->undelayed_write_many_valid_h)),
					CASE(0), c_reg_ipr->write_many_a(WRITE_MANY_SEC0_MSB, 0),
					CASE(1), CONCAT(c_reg_ipr->write_many_a(WRITE_MANY_SEC0_MSB-1, 0),
                                                        SWITCH(SEL(c->reset_a_h),
                                                               CASE(0), DFLOP(ACLK,m->cbox_ipr_out_8a_h),
                                                               CASE(1), c_mtv_cfg->write_many_a(WRITE_MANY_MSB)))));

// Rest of chain (and select) is delayed by a flop to match schematics...
c_reg_ipr->write_many_dly_flop_a = DFLOP(ACLK, c_reg_ipr->write_many_a(WRITE_MANY_SEC0_MSB));

c_reg_ipr->write_many_b(WRITE_MANY_MSB, WRITE_MANY_SEC0_MSB+1) = 
				    DLAT(BCLK,SWITCH(SEL((~c->reset_a_h & c_reg_ipr->write_many_shift_1a) |
                                                         ( c->reset_a_h & ~c_mtv_cfg->write_many_valid_h)),
					CASE(0), c_reg_ipr->write_many_a(WRITE_MANY_MSB, WRITE_MANY_SEC0_MSB+1),
					CASE(1), CONCAT(c_reg_ipr->write_many_a(WRITE_MANY_MSB-1, WRITE_MANY_SEC0_MSB+1),
							c_reg_ipr->write_many_dly_flop_a)));

c_reg_ipr->write_many_a(WRITE_MANY_MSB,0)  = DLAT(ACLK,c_reg_ipr->write_many_b(WRITE_MANY_MSB,0));

c_mtv_cfg->write_many_val_b(WRITE_MANY_MSB,0)  = DLAT(BCLK,SWITCH(SEL((~c->reset_a_h & DFLOP(ACLK,m->cbox_ipr_out_val_8a_h)) | 
                                                                      ( c->reset_a_h & ~c_mtv_cfg->undelayed_write_many_valid_h)),
					CASE(0), c_mtv_cfg->write_many_val_a(WRITE_MANY_MSB,0),
					CASE(1), CONCAT(c_mtv_cfg->write_many_val_a(WRITE_MANY_MSB - 1,0) & 
							REPLICATE(IN(~c_mtv_cfg->undelayed_write_many_valid_h),
								  SIZE(WRITE_MANY_MSB)),1)));
c_mtv_cfg->write_many_val_a(WRITE_MANY_MSB,0)  = DLAT(ACLK,c_mtv_cfg->write_many_val_b(WRITE_MANY_MSB,0));

// Have to use delayed write_many_valid for second part of chain--must use an "asynchronous" path to clear it
c_mtv_cfg->undelayed_write_many_valid_h = c_mtv_cfg->write_many_val_a(WRITE_MANY_MSB);
c_mtv_cfg->write_many_valid_h = DFLOP(ACLK, c_mtv_cfg->undelayed_write_many_valid_h) &
			   	c_mtv_cfg->undelayed_write_many_valid_h;

#else

//	CBOX WRITE ONCE chain
//
c_reg_ipr->write_once_a(WRITE_ONCE_MSB,0) = DFLOP(ACLK, SWITCH(SEL(c_reg_ipr->cbox_shift_a_h),
					CASE(0), c_reg_ipr->write_once_a(WRITE_ONCE_MSB,0),
					CASE(1), CONCAT(c_reg_ipr->write_once_a(WRITE_ONCE_MSB - 1,0),t->ica_sat_so_a_h)));

c_reg_ipr->cbox_shiftdone_a_h = t->cbox_shiftdone_a_h & t->enable_tbox;

//	CBOX WRITE MANY chain
//
c_reg_ipr->write_many_b(WRITE_MANY_MSB,0)  = DLAT(BCLK,SWITCH(SEL(DFLOP(ACLK,m->cbox_ipr_out_val_8a_h) | c->reset_a_h),
					CASE(0), c_reg_ipr->write_many_a(WRITE_MANY_MSB,0),
					CASE(1), CONCAT(c_reg_ipr->write_many_a(WRITE_MANY_MSB - 1,0),
                                                        DFLOP(ACLK,m->cbox_ipr_out_8a_h ) & ~c->reset_a_h)));
c_reg_ipr->write_many_a(WRITE_MANY_MSB,0)  = DLAT(ACLK,c_reg_ipr->write_many_b(WRITE_MANY_MSB,0));

//  this isn't in the real hardware but we still need it to qualify the duplicate signal checks
//
c_mtv_cfg->write_many_val_b(WRITE_MANY_MSB,0)  = DLAT(BCLK,SWITCH(SEL(DFLOP(ACLK,m->cbox_ipr_out_val_8a_h) & ~c->reset_a_h),
					CASE(0), c_mtv_cfg->write_many_val_a(WRITE_MANY_MSB,0),
					CASE(1), CONCAT(c_mtv_cfg->write_many_val_a(WRITE_MANY_MSB - 1,0) & 
							REPLICATE(IN(~c_mtv_cfg->write_many_valid_h),SIZE(WRITE_MANY_MSB)),1)));
c_mtv_cfg->write_many_val_a(WRITE_MANY_MSB,0)  = DLAT(ACLK,c_mtv_cfg->write_many_val_b(WRITE_MANY_MSB,0));

c_mtv_cfg->write_many_valid_h = c_mtv_cfg->write_many_val_a(WRITE_MANY_MSB);

#endif

//	CBOX READ ONCE chain  --> read will destroy data

// 	c_osb_arb->dcvictim_syndrome0_a(7,0)
//	c_osb_arb->dcvictim_syndrome1_a(7,0)
//	c->cbox_err_reg_code_bit4_a			
//	c_isb_ctl->cbox_err_reg_code_a(3,0)	
//	c_isb_ctl->cbox_err_sts_a(3,0)	
//	c_adp_flp->cbox_err_address_reg_a(42,6)	        




}

#endif

